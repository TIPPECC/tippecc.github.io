<script lang="ts">
	import { SvelteFlow, Controls, Background, BackgroundVariant, MarkerType } from '@xyflow/svelte';
	import { SvelteComponent, onMount } from 'svelte';
	//import * as d3 from 'd3'; // Import D3.js
	import '@xyflow/svelte/dist/style.css';

	import EntityNode from '$lib/components/entityNode_mini.svelte';
	import ActivityNode from '$lib/components/ActivityNode.svelte';
	import PersonNode from '$lib/components/PersonNode.svelte';
	import SoftwareNode from '$lib/components/SoftwareNode_mini.svelte';
	import Sidebar from '$lib/components/Sidebar.svelte'; // Import the Sidebar
	//import TopBar from '$lib/components/TopBar.svelte';

	import {
		isSwitchOn,
		updateLabels,
		wasDerivedFrom_lb,
		wasInformedBy_lb,
		wasAttributedTo_lb,
		actedOnBehalfOf_lb,
		wasAssociatedWith_lb,
		wasGeneratedBy_lb,
		used_lb,
		nodes_min,
		edges_min
	} from '$lib/store'; // Import the store

	//import data from '$lib/generate_rdfjson/article-prov.json';
	import data from '$lib/data/TIPPECC_ACCESS-ESM1-5_day_r1i1p1f1__evspsblpot__mm_1950_2100__yearsum_mean_2080_2099.json';
	//TIPPECC_ACCESS-CM2_day_r1i1p1f1__ai_1950_2100__yearsum_mean_1981_2000-2080_2099.json'

	import {
		AddActions,
		createPeople,
		addSoftware,
		addEdgesOnly,
		AddEntities
	} from '$lib/components//dataProcessing'; // Adjust path as necessary
	import {
		adjustPositionSoftware,
		adjustPositionPersons,
		adjustPositionActivities
	} from '$lib/components/adjustPositions';

	const defaultEdgeOptions = {
		style: 'stroke-width: 3; stroke: black; z-index: 1;',
		type: 'floating',
		markerEnd: {
			type: MarkerType.ArrowClosed,
			color: 'black'
		}
	};

	let minZoom = 0.01;

	const nodeTypes: Record<string, typeof SvelteComponent> = {
		entityNode: EntityNode as unknown as typeof SvelteComponent,
		activityNode: ActivityNode as unknown as typeof SvelteComponent,
		personNode: PersonNode as unknown as typeof SvelteComponent,
		softwareNode: SoftwareNode as unknown as typeof SvelteComponent
	};

	$: {
		updateLabels($isSwitchOn);
	}

	// Update edges with new labels whenever the label changes
	$: {
		edges_min.update((edges) => {
			return edges.map((edge) => {
				// Update the label based on the edge's existing label (edge.label)
				let label;
				switch (edge.label) {
					case 'derived from':
						label = $wasDerivedFrom_lb;
						break;
					case 'wasDerivedFrom':
						label = $wasDerivedFrom_lb;
						break;
					case 'followed by':
						label = $wasInformedBy_lb;
						break;
					case 'wasInformedBy':
						label = $wasInformedBy_lb;
						break;
					case 'resp. person':
						label = $wasAttributedTo_lb;
						break;
					case 'wasAttributedTo':
						label = $wasAttributedTo_lb;
						break;
					case 'works for organization':
						label = $actedOnBehalfOf_lb;
						break;
					case 'actedOnBehalfOf':
						label = $actedOnBehalfOf_lb;
						break;
					case 'part of software':
						label = $wasAssociatedWith_lb;
						break;
					case 'wasAssociatedWith':
						label = $wasAssociatedWith_lb;
						break;
					case 'generated by':
						label = $wasGeneratedBy_lb;
						break;
					case 'wasGeneratedBy':
						label = $wasGeneratedBy_lb;
						break;
					case 'used dataset':
						label = $used_lb;
						break;
					case 'used':
						label = $used_lb;
						break;
				}

				// Return the updated edge with the new label
				return { ...edge, label };
			});
		});
	}

	onMount(() => {
		// Adjust labels based on switch state

		// Clear the nodes and edges stores before repopulating them
		nodes_min.set([]);
		edges_min.set([]);

		//const hadMember = data.hadMember;
		AddEntities(data, nodes_min, edges_min, $wasDerivedFrom_lb, 'entityNode');

		AddActions(data, nodes_min, edges_min, $wasInformedBy_lb);

		// OPTIONAL: TRANSFER People and Organisation to Entity
		createPeople({
			dataset: data,
			nodes: nodes_min,
			edges: edges_min,
			EdgeLabel: $wasAttributedTo_lb,
			swapArrow: false,
			edgeStyle: 'stroke: #CC8400'
		});

		//Add Edges for Used
		addEdgesOnly({
			dataset: data.used,
			edges: edges_min,
			EdgeLabel: $used_lb,
			IdName: 'prov:activity',
			EntityName: 'prov:entity',
			swapArrow: false,
			style: 'stroke: #88BCE4;',
			labelStyle: 'color: black; font-size: 16px',
			handle1: 'right',
			handle2: 'left',
			IdAppendix: 'used'
		});

		// Add Edges for wasGeneratedBy
		addEdgesOnly({
			dataset: data.wasGeneratedBy,
			edges: edges_min,
			EdgeLabel: $wasGeneratedBy_lb,
			IdName: 'prov:entity',
			EntityName: 'prov:activity',
			swapArrow: true,
			style: 'stroke: #6BAF74;',
			labelStyle: 'color: black; font-size: 16px',
			handle1: 'right',
			handle2: 'left',
			IdAppendix: 'wasGeneratedBy'
		});

		//Add Software Nodes
		addSoftware({
			dataset: data,
			nodes: nodes_min,
			edges: edges_min,
			EdgeLabel: $wasAssociatedWith_lb,
			IdName: 'prov:activity',
			EntityName: 'prov:agent',
			swapArrow: true,
			edgestyle: 'stroke: #CE93D8;'
		});

		adjustPositionActivities({
			edges: edges_min,
			nodes: nodes_min,
			EdgeLabel: $wasGeneratedBy_lb,
			EdgeLabel2: $used_lb
		});

		adjustPositionSoftware({
			edges: edges_min,
			nodes: nodes_min,
			EdgeLabel: $wasAssociatedWith_lb
		});

		adjustPositionPersons({
			edges: edges_min,
			nodes: nodes_min,
			EdgeLabel: $wasAttributedTo_lb,
			NodeType: 'personNode'
		});
	});
</script>

<div style="height: 1000px;">
	<SvelteFlow
		{minZoom}
		nodes={nodes_min}
		edges={edges_min}
		{defaultEdgeOptions}
		{nodeTypes}
		fitView
	>
		<Controls />
		<Background variant={BackgroundVariant.Dots} />
	</SvelteFlow>
	<Sidebar />
</div>
